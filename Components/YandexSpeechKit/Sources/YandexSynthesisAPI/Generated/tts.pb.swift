// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tts.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Speechkit_Tts_V3_AudioContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The audio source to read the data from.
  public var audioSource: Speechkit_Tts_V3_AudioContent.OneOf_AudioSource? = nil

  public var content: Data {
    get {
      if case .content(let v)? = audioSource {return v}
      return Data()
    }
    set {audioSource = .content(newValue)}
  }

  /// Description of the audio format.
  public var audioSpec: Speechkit_Tts_V3_AudioFormatOptions {
    get {return _audioSpec ?? Speechkit_Tts_V3_AudioFormatOptions()}
    set {_audioSpec = newValue}
  }
  /// Returns true if `audioSpec` has been explicitly set.
  public var hasAudioSpec: Bool {return self._audioSpec != nil}
  /// Clears the value of `audioSpec`. Subsequent reads from it will return its default value.
  public mutating func clearAudioSpec() {self._audioSpec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The audio source to read the data from.
  public enum OneOf_AudioSource: Equatable {
    case content(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Speechkit_Tts_V3_AudioContent.OneOf_AudioSource, rhs: Speechkit_Tts_V3_AudioContent.OneOf_AudioSource) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.content, .content): return {
        guard case .content(let l) = lhs, case .content(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _audioSpec: Speechkit_Tts_V3_AudioFormatOptions? = nil
}

public struct Speechkit_Tts_V3_AudioFormatOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var audioFormat: Speechkit_Tts_V3_AudioFormatOptions.OneOf_AudioFormat? = nil

  /// The audio format specified in request parameters.
  public var rawAudio: Speechkit_Tts_V3_RawAudio {
    get {
      if case .rawAudio(let v)? = audioFormat {return v}
      return Speechkit_Tts_V3_RawAudio()
    }
    set {audioFormat = .rawAudio(newValue)}
  }

  /// The audio format specified inside the file header.
  public var containerAudio: Speechkit_Tts_V3_ContainerAudio {
    get {
      if case .containerAudio(let v)? = audioFormat {return v}
      return Speechkit_Tts_V3_ContainerAudio()
    }
    set {audioFormat = .containerAudio(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_AudioFormat: Equatable {
    /// The audio format specified in request parameters.
    case rawAudio(Speechkit_Tts_V3_RawAudio)
    /// The audio format specified inside the file header.
    case containerAudio(Speechkit_Tts_V3_ContainerAudio)

  #if !swift(>=4.1)
    public static func ==(lhs: Speechkit_Tts_V3_AudioFormatOptions.OneOf_AudioFormat, rhs: Speechkit_Tts_V3_AudioFormatOptions.OneOf_AudioFormat) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rawAudio, .rawAudio): return {
        guard case .rawAudio(let l) = lhs, case .rawAudio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.containerAudio, .containerAudio): return {
        guard case .containerAudio(let l) = lhs, case .containerAudio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Speechkit_Tts_V3_RawAudio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Encoding type.
  public var audioEncoding: Speechkit_Tts_V3_RawAudio.AudioEncoding = .unspecified

  /// Sampling frequency of the signal.
  public var sampleRateHertz: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AudioEncoding: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// 16-bit signed little-endian (Linear PCM)
    case linear16Pcm // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .linear16Pcm
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .linear16Pcm: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Speechkit_Tts_V3_RawAudio.AudioEncoding: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Speechkit_Tts_V3_RawAudio.AudioEncoding] = [
    .unspecified,
    .linear16Pcm,
  ]
}

#endif  // swift(>=4.2)

public struct Speechkit_Tts_V3_ContainerAudio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var containerAudioType: Speechkit_Tts_V3_ContainerAudio.ContainerAudioType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ContainerAudioType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// RIFF linear pcm with header audio file format.
    case wav // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .wav
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .wav: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Speechkit_Tts_V3_ContainerAudio.ContainerAudioType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Speechkit_Tts_V3_ContainerAudio.ContainerAudioType] = [
    .unspecified,
    .wav,
  ]
}

#endif  // swift(>=4.2)

public struct Speechkit_Tts_V3_TextVariable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var variableName: String = String()

  /// The text of the variable to be synthesized instead of the template.
  public var variableValue: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Speechkit_Tts_V3_AudioVariable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var variableName: String = String()

  public var variableStartMs: Int64 = 0

  public var variableLengthMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Speechkit_Tts_V3_UtteranceSynthesisResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Part of synthesized audio.
  public var audioChunk: Speechkit_Tts_V3_AudioChunk {
    get {return _audioChunk ?? Speechkit_Tts_V3_AudioChunk()}
    set {_audioChunk = newValue}
  }
  /// Returns true if `audioChunk` has been explicitly set.
  public var hasAudioChunk: Bool {return self._audioChunk != nil}
  /// Clears the value of `audioChunk`. Subsequent reads from it will return its default value.
  public mutating func clearAudioChunk() {self._audioChunk = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _audioChunk: Speechkit_Tts_V3_AudioChunk? = nil
}

public struct Speechkit_Tts_V3_AudioTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var audio: Speechkit_Tts_V3_AudioContent {
    get {return _audio ?? Speechkit_Tts_V3_AudioContent()}
    set {_audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  public var hasAudio: Bool {return self._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  public mutating func clearAudio() {self._audio = nil}

  public var textTemplate: Speechkit_Tts_V3_TextTemplate {
    get {return _textTemplate ?? Speechkit_Tts_V3_TextTemplate()}
    set {_textTemplate = newValue}
  }
  /// Returns true if `textTemplate` has been explicitly set.
  public var hasTextTemplate: Bool {return self._textTemplate != nil}
  /// Clears the value of `textTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearTextTemplate() {self._textTemplate = nil}

  public var variables: [Speechkit_Tts_V3_AudioVariable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _audio: Speechkit_Tts_V3_AudioContent? = nil
  fileprivate var _textTemplate: Speechkit_Tts_V3_TextTemplate? = nil
}

public struct Speechkit_Tts_V3_AudioChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sequence of bytes of the synthesized audio in format specified in output_audio_spec
  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Speechkit_Tts_V3_TextTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// hello, {user}
  public var textTemplate: String = String()

  ///{user: Adam}
  public var variables: [Speechkit_Tts_V3_TextVariable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Speechkit_Tts_V3_Hints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hint for specifying the voice that need to synthesize in the audio.
  public var hint: Speechkit_Tts_V3_Hints.OneOf_Hint? = nil

  public var voice: String {
    get {
      if case .voice(let v)? = hint {return v}
      return String()
    }
    set {hint = .voice(newValue)}
  }

  public var audioTemplate: Speechkit_Tts_V3_AudioTemplate {
    get {
      if case .audioTemplate(let v)? = hint {return v}
      return Speechkit_Tts_V3_AudioTemplate()
    }
    set {hint = .audioTemplate(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The hint for specifying the voice that need to synthesize in the audio.
  public enum OneOf_Hint: Equatable {
    case voice(String)
    case audioTemplate(Speechkit_Tts_V3_AudioTemplate)

  #if !swift(>=4.1)
    public static func ==(lhs: Speechkit_Tts_V3_Hints.OneOf_Hint, rhs: Speechkit_Tts_V3_Hints.OneOf_Hint) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.voice, .voice): return {
        guard case .voice(let l) = lhs, case .voice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audioTemplate, .audioTemplate): return {
        guard case .audioTemplate(let l) = lhs, case .audioTemplate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Speechkit_Tts_V3_UtteranceSynthesisRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var model: String = String()

  /// Text to synthesis, one of for advanced mark up in future
  public var utterance: Speechkit_Tts_V3_UtteranceSynthesisRequest.OneOf_Utterance? = nil

  public var text: String {
    get {
      if case .text(let v)? = utterance {return v}
      return String()
    }
    set {utterance = .text(newValue)}
  }

  public var textTemplate: Speechkit_Tts_V3_TextTemplate {
    get {
      if case .textTemplate(let v)? = utterance {return v}
      return Speechkit_Tts_V3_TextTemplate()
    }
    set {utterance = .textTemplate(newValue)}
  }

  /// Optional hints for synthesis.
  public var hints: [Speechkit_Tts_V3_Hints] = []

  /// Optional. Default: 22050 Hz, linear 16-bit signed little-endian pcm
  public var outputAudioSpec: Speechkit_Tts_V3_AudioFormatOptions {
    get {return _outputAudioSpec ?? Speechkit_Tts_V3_AudioFormatOptions()}
    set {_outputAudioSpec = newValue}
  }
  /// Returns true if `outputAudioSpec` has been explicitly set.
  public var hasOutputAudioSpec: Bool {return self._outputAudioSpec != nil}
  /// Clears the value of `outputAudioSpec`. Subsequent reads from it will return its default value.
  public mutating func clearOutputAudioSpec() {self._outputAudioSpec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Text to synthesis, one of for advanced mark up in future
  public enum OneOf_Utterance: Equatable {
    case text(String)
    case textTemplate(Speechkit_Tts_V3_TextTemplate)

  #if !swift(>=4.1)
    public static func ==(lhs: Speechkit_Tts_V3_UtteranceSynthesisRequest.OneOf_Utterance, rhs: Speechkit_Tts_V3_UtteranceSynthesisRequest.OneOf_Utterance) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.textTemplate, .textTemplate): return {
        guard case .textTemplate(let l) = lhs, case .textTemplate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _outputAudioSpec: Speechkit_Tts_V3_AudioFormatOptions? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "speechkit.tts.v3"

extension Speechkit_Tts_V3_AudioContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .standard(proto: "audio_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.audioSource != nil {try decoder.handleConflictingOneOf()}
          self.audioSource = .content(v)
        }
      }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._audioSpec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .content(let v)? = self.audioSource {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._audioSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_AudioContent, rhs: Speechkit_Tts_V3_AudioContent) -> Bool {
    if lhs.audioSource != rhs.audioSource {return false}
    if lhs._audioSpec != rhs._audioSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechkit_Tts_V3_AudioFormatOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioFormatOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_audio"),
    2: .standard(proto: "container_audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Speechkit_Tts_V3_RawAudio?
        var hadOneofValue = false
        if let current = self.audioFormat {
          hadOneofValue = true
          if case .rawAudio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.audioFormat = .rawAudio(v)
        }
      }()
      case 2: try {
        var v: Speechkit_Tts_V3_ContainerAudio?
        var hadOneofValue = false
        if let current = self.audioFormat {
          hadOneofValue = true
          if case .containerAudio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.audioFormat = .containerAudio(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.audioFormat {
    case .rawAudio?: try {
      guard case .rawAudio(let v)? = self.audioFormat else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .containerAudio?: try {
      guard case .containerAudio(let v)? = self.audioFormat else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_AudioFormatOptions, rhs: Speechkit_Tts_V3_AudioFormatOptions) -> Bool {
    if lhs.audioFormat != rhs.audioFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechkit_Tts_V3_RawAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RawAudio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_encoding"),
    2: .standard(proto: "sample_rate_hertz"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.audioEncoding) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.sampleRateHertz) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.audioEncoding != .unspecified {
      try visitor.visitSingularEnumField(value: self.audioEncoding, fieldNumber: 1)
    }
    if self.sampleRateHertz != 0 {
      try visitor.visitSingularInt64Field(value: self.sampleRateHertz, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_RawAudio, rhs: Speechkit_Tts_V3_RawAudio) -> Bool {
    if lhs.audioEncoding != rhs.audioEncoding {return false}
    if lhs.sampleRateHertz != rhs.sampleRateHertz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechkit_Tts_V3_RawAudio.AudioEncoding: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO_ENCODING_UNSPECIFIED"),
    1: .same(proto: "LINEAR16_PCM"),
  ]
}

extension Speechkit_Tts_V3_ContainerAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContainerAudio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "container_audio_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.containerAudioType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.containerAudioType != .unspecified {
      try visitor.visitSingularEnumField(value: self.containerAudioType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_ContainerAudio, rhs: Speechkit_Tts_V3_ContainerAudio) -> Bool {
    if lhs.containerAudioType != rhs.containerAudioType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechkit_Tts_V3_ContainerAudio.ContainerAudioType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTAINER_AUDIO_TYPE_UNSPECIFIED"),
    1: .same(proto: "WAV"),
  ]
}

extension Speechkit_Tts_V3_TextVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextVariable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variable_name"),
    2: .standard(proto: "variable_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variableName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.variableValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variableName.isEmpty {
      try visitor.visitSingularStringField(value: self.variableName, fieldNumber: 1)
    }
    if !self.variableValue.isEmpty {
      try visitor.visitSingularStringField(value: self.variableValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_TextVariable, rhs: Speechkit_Tts_V3_TextVariable) -> Bool {
    if lhs.variableName != rhs.variableName {return false}
    if lhs.variableValue != rhs.variableValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechkit_Tts_V3_AudioVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioVariable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variable_name"),
    2: .standard(proto: "variable_start_ms"),
    3: .standard(proto: "variable_length_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variableName) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.variableStartMs) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.variableLengthMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variableName.isEmpty {
      try visitor.visitSingularStringField(value: self.variableName, fieldNumber: 1)
    }
    if self.variableStartMs != 0 {
      try visitor.visitSingularInt64Field(value: self.variableStartMs, fieldNumber: 2)
    }
    if self.variableLengthMs != 0 {
      try visitor.visitSingularInt64Field(value: self.variableLengthMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_AudioVariable, rhs: Speechkit_Tts_V3_AudioVariable) -> Bool {
    if lhs.variableName != rhs.variableName {return false}
    if lhs.variableStartMs != rhs.variableStartMs {return false}
    if lhs.variableLengthMs != rhs.variableLengthMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechkit_Tts_V3_UtteranceSynthesisResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UtteranceSynthesisResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_chunk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._audioChunk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._audioChunk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_UtteranceSynthesisResponse, rhs: Speechkit_Tts_V3_UtteranceSynthesisResponse) -> Bool {
    if lhs._audioChunk != rhs._audioChunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechkit_Tts_V3_AudioTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioTemplate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "audio"),
    2: .standard(proto: "text_template"),
    3: .same(proto: "variables"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._audio) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._textTemplate) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.variables) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._audio {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._textTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_AudioTemplate, rhs: Speechkit_Tts_V3_AudioTemplate) -> Bool {
    if lhs._audio != rhs._audio {return false}
    if lhs._textTemplate != rhs._textTemplate {return false}
    if lhs.variables != rhs.variables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechkit_Tts_V3_AudioChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioChunk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_AudioChunk, rhs: Speechkit_Tts_V3_AudioChunk) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechkit_Tts_V3_TextTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextTemplate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "text_template"),
    2: .same(proto: "variables"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.textTemplate) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.variables) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.textTemplate.isEmpty {
      try visitor.visitSingularStringField(value: self.textTemplate, fieldNumber: 1)
    }
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_TextTemplate, rhs: Speechkit_Tts_V3_TextTemplate) -> Bool {
    if lhs.textTemplate != rhs.textTemplate {return false}
    if lhs.variables != rhs.variables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechkit_Tts_V3_Hints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Hints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "voice"),
    2: .standard(proto: "audio_template"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.hint != nil {try decoder.handleConflictingOneOf()}
          self.hint = .voice(v)
        }
      }()
      case 2: try {
        var v: Speechkit_Tts_V3_AudioTemplate?
        var hadOneofValue = false
        if let current = self.hint {
          hadOneofValue = true
          if case .audioTemplate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hint = .audioTemplate(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.hint {
    case .voice?: try {
      guard case .voice(let v)? = self.hint else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .audioTemplate?: try {
      guard case .audioTemplate(let v)? = self.hint else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_Hints, rhs: Speechkit_Tts_V3_Hints) -> Bool {
    if lhs.hint != rhs.hint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Speechkit_Tts_V3_UtteranceSynthesisRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UtteranceSynthesisRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
    2: .same(proto: "text"),
    3: .standard(proto: "text_template"),
    4: .same(proto: "hints"),
    5: .standard(proto: "output_audio_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.utterance != nil {try decoder.handleConflictingOneOf()}
          self.utterance = .text(v)
        }
      }()
      case 3: try {
        var v: Speechkit_Tts_V3_TextTemplate?
        var hadOneofValue = false
        if let current = self.utterance {
          hadOneofValue = true
          if case .textTemplate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.utterance = .textTemplate(v)
        }
      }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.hints) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._outputAudioSpec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.utterance {
    case .text?: try {
      guard case .text(let v)? = self.utterance else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .textTemplate?: try {
      guard case .textTemplate(let v)? = self.utterance else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.hints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hints, fieldNumber: 4)
    }
    if let v = self._outputAudioSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Speechkit_Tts_V3_UtteranceSynthesisRequest, rhs: Speechkit_Tts_V3_UtteranceSynthesisRequest) -> Bool {
    if lhs.model != rhs.model {return false}
    if lhs.utterance != rhs.utterance {return false}
    if lhs.hints != rhs.hints {return false}
    if lhs._outputAudioSpec != rhs._outputAudioSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
